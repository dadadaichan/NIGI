using System.Collections;
using UnityEngine;

public class EnemyScanner : MonoBehaviour
{
    public GameObject nearestObj;
    public GameObject lockOn;
    public GameObject playerCenter;
    public float lockOnInterval;
    public float lockOnAngle;
    public Vector3 dir;

    private GameObject preNearestObj;
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        StartCoroutine(ScanEnemyTag());
        //lockOn.SetActive(false);
    }

    // Update is called once per frame
    void Update()
    {
        
    }

    IEnumerator ScanEnemyTag()
    {
        while (true)
        {
            float distancePlayerToEnemy = float.MaxValue;//最初に距離の最大入れとくことで一回目にどんな値が来ても最も短い距離と判定するため

            foreach (GameObject o in EnemyManager.Instance.enemies)
            {
                float distancePlayerToElement = Vector3.Distance(this.gameObject.transform.position, o.transform.position);
                if (distancePlayerToElement < distancePlayerToEnemy)
                {
                    nearestObj = o;
                    distancePlayerToEnemy = distancePlayerToElement;
                }
            }

            if(nearestObj != null)
            {
                lockOn.SetActive(true);
                if(nearestObj != preNearestObj)
                {
                    lockOn.transform.SetParent(nearestObj.transform, false);
                    lockOn.transform.localPosition = new Vector3(0, 0, 0);
                    preNearestObj = nearestObj;
                }
            }
            else
            {
                lockOn.SetActive(false);
                nearestObj = null;
            }
            AngleCal();
                
            yield return new WaitForSeconds(lockOnInterval);
        }
    }

    public void AngleCal()
    {
        dir = (nearestObj.transform.position - playerCenter.transform.position).normalized;
        lockOnAngle = Mathf.Atan2(dir.y, dir.x) * Mathf.Rad2Deg;
    }
}
//【目標】プレイヤーから最も近い敵をロックオンする。
//1.すべてのTag「Enemy」のオブジェクトを検索。⇒配列に入れる。
//※毎フレームやると重くなる、かつ、敵が多い場合ロックオンが荒ぶる。⇒数秒おきに実行。（IEnumeratorでコルーチン）
//2.配列内の一つ一つのオブジェクトとプレイヤーの距離を計算。（繰り返し処理）
//※foreach(GameObject o in 配列名）で「配列の中から一つ取り出して、oに代入して処理を行う。」を配列の終わりまで繰り返す。
//3.これまでの最短距離オブジェクト＞配列内の最短距離オブジェクト（if文）⇒後者をロックオン。
